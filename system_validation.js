#!/usr/bin/env node

/**
 * BioSpark Health AI - Comprehensive System Validation
 * BMAD Delta Phase - Integration Testing & Validation
 * Generated by BMAD Agent Delta
 */

const fs = require('fs');
const path = require('path');

async function validateSystem() {
  console.log('üî¨ BioSpark Health AI - System Validation Report');
  console.log('=' .repeat(60));
  console.log(`Timestamp: ${new Date().toISOString()}`);
  console.log(`Node Version: ${process.version}`);
  console.log('=' .repeat(60));

  const results = {
    timestamp: new Date().toISOString(),
    environment: 'development',
    tests: [],
    summary: {
      total: 0,
      passed: 0,
      failed: 0,
      warnings: 0
    }
  };

  // Test 1: Environment Configuration
  await testEnvironmentConfig(results);
  
  // Test 2: Database Connectivity
  await testDatabaseConnectivity(results);
  
  // Test 3: API Endpoints
  await testAPIEndpoints(results);
  
  // Test 4: File System & Dependencies
  await testFileSystemAndDeps(results);
  
  // Test 5: Security & Compliance
  await testSecurityCompliance(results);

  // Generate Summary
  generateSummary(results);
  
  // Save Results
  await saveResults(results);
  
  return results;
}

async function testEnvironmentConfig(results) {
  console.log('\nüìã Testing Environment Configuration...');
  
  const envTests = [
    { name: 'DATABASE_URL', required: true },
    { name: 'OPENAI_API_KEY', required: true },
    { name: 'ZEP_API_KEY', required: true },
    { name: 'NEXTAUTH_SECRET', required: true },
    { name: 'ENCRYPTION_KEY', required: true }
  ];

  for (const test of envTests) {
    const value = process.env[test.name];
    const passed = test.required ? !!value && !value.includes('[YOUR-') : true;
    
    results.tests.push({
      category: 'Environment',
      name: test.name,
      status: passed ? 'PASS' : 'FAIL',
      message: passed ? 'Configured correctly' : 'Missing or contains placeholder',
      critical: test.required
    });
    
    console.log(`  ${passed ? '‚úÖ' : '‚ùå'} ${test.name}: ${passed ? 'OK' : 'MISSING/PLACEHOLDER'}`);
  }
}

async function testDatabaseConnectivity(results) {
  console.log('\nüóÑÔ∏è  Testing Database Connectivity...');
  
  try {
    const response = await fetch('http://localhost:3000/api/health');
    const health = await response.json();
    
    const dbHealthy = health.services?.database?.status === 'healthy';
    
    results.tests.push({
      category: 'Database',
      name: 'Connection Health',
      status: dbHealthy ? 'PASS' : 'FAIL',
      message: dbHealthy ? 'Database connected successfully' : 'Database connection failed',
      critical: true,
      details: health.services?.database
    });
    
    console.log(`  ${dbHealthy ? '‚úÖ' : '‚ùå'} Database Connection: ${dbHealthy ? 'HEALTHY' : 'FAILED'}`);
    
  } catch (error) {
    results.tests.push({
      category: 'Database',
      name: 'Connection Health',
      status: 'FAIL',
      message: `Database test failed: ${error.message}`,
      critical: true
    });
    console.log(`  ‚ùå Database Connection: ERROR - ${error.message}`);
  }
}

async function testAPIEndpoints(results) {
  console.log('\nüåê Testing API Endpoints...');
  
  const endpoints = [
    { path: '/api/health', method: 'GET', critical: true },
    { path: '/api/comprehensive-analysis', method: 'POST', critical: true, requiresData: true }
  ];

  for (const endpoint of endpoints) {
    try {
      let response;
      
      if (endpoint.requiresData) {
        // Test with minimal form data
        const formData = new FormData();
        formData.append('email', 'test@validation.com');
        formData.append('initials', 'TV');
        formData.append('age', '30');
        formData.append('city', 'TestCity');
        formData.append('file', new Blob(['test content'], { type: 'application/pdf' }), 'test.pdf');
        
        response = await fetch(`http://localhost:3000${endpoint.path}`, {
          method: endpoint.method,
          body: formData
        });
      } else {
        response = await fetch(`http://localhost:3000${endpoint.path}`, {
          method: endpoint.method
        });
      }
      
      const isSuccess = response.ok || response.status < 500;
      
      results.tests.push({
        category: 'API',
        name: `${endpoint.method} ${endpoint.path}`,
        status: isSuccess ? 'PASS' : 'FAIL',
        message: `HTTP ${response.status} - ${isSuccess ? 'Responding correctly' : 'Server error'}`,
        critical: endpoint.critical,
        details: { status: response.status, statusText: response.statusText }
      });
      
      console.log(`  ${isSuccess ? '‚úÖ' : '‚ùå'} ${endpoint.method} ${endpoint.path}: ${response.status}`);
      
    } catch (error) {
      results.tests.push({
        category: 'API',
        name: `${endpoint.method} ${endpoint.path}`,
        status: 'FAIL',
        message: `Request failed: ${error.message}`,
        critical: endpoint.critical
      });
      console.log(`  ‚ùå ${endpoint.method} ${endpoint.path}: ERROR - ${error.message}`);
    }
  }
}

async function testFileSystemAndDeps(results) {
  console.log('\nüìÅ Testing File System & Dependencies...');
  
  const criticalPaths = [
    { path: './package.json', type: 'file' },
    { path: './app/api', type: 'directory' },
    { path: './lib', type: 'directory' },
    { path: './prisma', type: 'directory' },
    { path: './.env.local', type: 'file' }
  ];

  for (const item of criticalPaths) {
    try {
      const exists = fs.existsSync(item.path);
      const stats = exists ? fs.statSync(item.path) : null;
      const isCorrectType = stats && (
        (item.type === 'file' && stats.isFile()) ||
        (item.type === 'directory' && stats.isDirectory())
      );
      
      const passed = exists && isCorrectType;
      
      results.tests.push({
        category: 'FileSystem',
        name: item.path,
        status: passed ? 'PASS' : 'FAIL',
        message: passed ? `${item.type} exists and accessible` : `${item.type} missing or inaccessible`,
        critical: true
      });
      
      console.log(`  ${passed ? '‚úÖ' : '‚ùå'} ${item.path}: ${passed ? 'OK' : 'MISSING'}`);
      
    } catch (error) {
      results.tests.push({
        category: 'FileSystem',
        name: item.path,
        status: 'FAIL',
        message: `Access error: ${error.message}`,
        critical: true
      });
      console.log(`  ‚ùå ${item.path}: ERROR - ${error.message}`);
    }
  }
}

async function testSecurityCompliance(results) {
  console.log('\nüîí Testing Security & Compliance...');
  
  const securityChecks = [
    {
      name: 'Environment Secrets',
      check: () => {
        const envContent = fs.readFileSync('./.env.local', 'utf8');
        return !envContent.includes('[YOUR-') && !envContent.includes('placeholder');
      }
    },
    {
      name: 'HTTPS Ready',
      check: () => {
        const packageJson = JSON.parse(fs.readFileSync('./package.json', 'utf8'));
        return packageJson.dependencies && Object.keys(packageJson.dependencies).length > 0;
      }
    },
    {
      name: 'Encryption Libraries',
      check: () => {
        try {
          const cryptoLib = fs.existsSync('./lib/crypto.ts') || fs.existsSync('./lib/crypto.js');
          return cryptoLib;
        } catch {
          return false;
        }
      }
    }
  ];

  for (const check of securityChecks) {
    try {
      const passed = check.check();
      
      results.tests.push({
        category: 'Security',
        name: check.name,
        status: passed ? 'PASS' : 'WARN',
        message: passed ? 'Security check passed' : 'Security check needs attention',
        critical: false
      });
      
      console.log(`  ${passed ? '‚úÖ' : '‚ö†Ô∏è'} ${check.name}: ${passed ? 'OK' : 'NEEDS ATTENTION'}`);
      
    } catch (error) {
      results.tests.push({
        category: 'Security',
        name: check.name,
        status: 'FAIL',
        message: `Security check failed: ${error.message}`,
        critical: false
      });
      console.log(`  ‚ùå ${check.name}: ERROR - ${error.message}`);
    }
  }
}

function generateSummary(results) {
  console.log('\nüìä Test Summary');
  console.log('=' .repeat(40));
  
  results.summary.total = results.tests.length;
  results.summary.passed = results.tests.filter(t => t.status === 'PASS').length;
  results.summary.failed = results.tests.filter(t => t.status === 'FAIL').length;
  results.summary.warnings = results.tests.filter(t => t.status === 'WARN').length;
  
  const criticalFailures = results.tests.filter(t => t.status === 'FAIL' && t.critical).length;
  
  console.log(`Total Tests: ${results.summary.total}`);
  console.log(`‚úÖ Passed: ${results.summary.passed}`);
  console.log(`‚ùå Failed: ${results.summary.failed}`);
  console.log(`‚ö†Ô∏è  Warnings: ${results.summary.warnings}`);
  console.log(`üö® Critical Failures: ${criticalFailures}`);
  
  results.summary.systemHealth = criticalFailures === 0 ? 'HEALTHY' : 'NEEDS ATTENTION';
  results.summary.readyForProduction = criticalFailures === 0 && results.summary.failed === 0;
  
  console.log(`\nüè• System Health: ${results.summary.systemHealth}`);
  console.log(`üöÄ Production Ready: ${results.summary.readyForProduction ? 'YES' : 'NO'}`);
}

async function saveResults(results) {
  const reportPath = './system_validation_report.json';
  fs.writeFileSync(reportPath, JSON.stringify(results, null, 2));
  console.log(`\nüìÑ Full report saved to: ${reportPath}`);
}

// Run validation if called directly
if (require.main === module) {
  validateSystem().catch(console.error);
}

module.exports = { validateSystem };
